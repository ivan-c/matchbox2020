---
version: "3.4"
x-dnsmasq-base: &dnsmasq_base
  build:
    dockerfile: Dockerfile.dnsmasq
    context: .
  entrypoint:
    - dnsmasq
    - --log-facility=-
    - --keep-in-foreground
    - --user=root

services:
  matchbox:
    build:
      dockerfile: Dockerfile.matchbox
      context: .
    volumes:
      - ./:/tmp/matchbox:ro
      - ./docker-entrypoint.sh:/bin/entrypoint.sh:ro
      - ./docker-entrypoint.d:/docker-entrypoint.d:ro
    environment:
      MATCHBOX_LOG_LEVEL: debug
      MATCHBOX_ADDRESS: 0.0.0.0:8080
      MATCHBOX_ASSETS_PATH: /tmp
    entrypoint: /bin/entrypoint.sh
    command: /bin/matchbox
    env_file: matchbox.env
    ports:
      - 8080:8080

  dhcpd:
    <<: *dnsmasq_base
    # todo: use dhcp relay
    network_mode: host
    command:
      - --log-queries
      - --log-dhcp

      - --dhcp-range=192.168.1.0,proxy

      # if DHCP userclass is iPXE, add ipxe tag
      - --dhcp-userclass=set:ipxe,iPXE

      # tag arm64 UEFI by client-arch
      - --dhcp-match=set:efi-arm64,option:client-arch,11

      # boot iPXE arm64 EFI from UEFI
      - --dhcp-boot=tag:efi-arm64,tag:!ipxe,ipxe.build.efi

      # Raspberry Pi uses the same client-arch as PC BIOS and downloads its own set of files
      - --pxe-service=tag:!ipxe,x86PC,Raspberry Pi Boot,Netboot RaspberryPi,${next_server}


      # 1st request: download BIOS iPXE image via TFTP and run
      - --pxe-service=tag:!ipxe,x86PC,Boot iPXE with BIOS,undionly.kpxe,${next_server}
      # 1st request: download EFI iPXE image via TFTP and run
      - --pxe-service=tag:!ipxe,x86-64_EFI,Boot iPXE with EFI,ipxe.efi,${next_server}

      # 2nd request: download iPXE script via HTTP and run
      - --dhcp-boot=tag:ipxe,http://${next_server}:8080/boot.ipxe

    ports:
      # DHCP
      - "67:67/udp"

  tftpd:
    <<: *dnsmasq_base
    command:
      - --port=0
      - --enable-tftp
      - --tftp-root=/var/lib/tftpboot
    ports:
      - "69:69/udp"
